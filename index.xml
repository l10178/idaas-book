<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>IDaaS Book on A book about IDaaS</title><link>https://l10178.github.io/idaas-book/</link><description>Recent content in IDaaS Book on A book about IDaaS</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Fri, 04 Dec 2020 23:54:37 +0800</lastBuildDate><atom:link href="https://l10178.github.io/idaas-book/index.xml" rel="self" type="application/rss+xml"/><item><title>Keycloak 简介</title><link>https://l10178.github.io/idaas-book/keycloak/getting-started/</link><pubDate>Sat, 26 Sep 2020 18:54:37 +0800</pubDate><guid>https://l10178.github.io/idaas-book/keycloak/getting-started/</guid><description>keycloak 是一个开源的、面向现代应用和服务的 IAM（身份认证和访问控制）解决方案。
主要功能：
SSO
单点登录（Single-Sign On），支持 OpenID Connect、OAuth 2.0、SAML 2.0 标准协议。 Identity Brokering and Social Login
通过配置，可实现对不同身份认证服务的集成，通过这些身份认证服务登录应用。如 GitHub、Google 等，开源社区也有人提供了微信集成方案。 User Federation
用户联合，提供了对 LDAP、Active Directory、Kerberos 的集成方案。 Client Adapters
不同平台多种语言的支持，Java、Python、Go、Node.js、Spring、Quarkus 等。 后台管理
提供了多种语言的后台管理界面，如果想偷懒的话改改图标定制个主题就能拿来用。同时还有 CLI 、SDK 和 RESTful API。 授权服务
提供基于 RBAC、ABAC、UBAC 等多种策略的授权功能。 其他常用功能
密码策略、暴力检测、MFA、日志审计。 选型参考 为什么可能选他：
Redhat 开源，CNCF 项目，稳定质量可靠，一直在演进和更新。 易开发易扩展，相对 CAS，尤其是对于 Java 开发者。 功能丰富易用，如果只是要一个简单的 IAM，几乎是开箱即用。 标准实现，易集成，大厂背书。Kubernetes、Grafana、Kibana、Rancher、Vault、Harbor、Jenkins、Activiti 等等天然支持。 为什么可能不选他：
如果你有定制开发的话，版本升级并不友好，也不太难，因人而异。 中文并不友好，包括界面中的中文翻译其实不符合国人习惯，这也是为啥有 IDaaS Book 这个项目。 名词解释 IAM Identity and Access Management，身份认证和访问控制。</description></item><item><title>Kubernetes中导入导出</title><link>https://l10178.github.io/idaas-book/keycloak/troubleshooting/export-import-on-k8s/</link><pubDate>Sun, 10 Jan 2021 23:59:00 +0800</pubDate><guid>https://l10178.github.io/idaas-book/keycloak/troubleshooting/export-import-on-k8s/</guid><description>问题描述 我的 keycloak 集群是跑在 Kubernetes 上，初始化了一些配置想完整的导出来。
比如按照官方的指导文档，在 keycloak pod 内用下面的命令导出。
./standalone.sh -Dkeycloak.migration.action=export -Dkeycloak.migration.provider=singleFile -Dkeycloak.migration.file=keycloak-export.json 出现类似下面错误。
ERROR [org.jboss.as.controller.management-operation] (Controller Boot Thread) WFLYCTL0013: Operation (&amp;quot;add&amp;quot;) failed - address: ([ (&amp;quot;core-service&amp;quot; =&amp;gt; &amp;quot;management&amp;quot;), (&amp;quot;management-interface&amp;quot; =&amp;gt; &amp;quot;http-interface&amp;quot;) ]) - failure description: { &amp;quot;WFLYCTL0080: Failed services&amp;quot; =&amp;gt; {&amp;quot;org.wildfly.management.http.extensible&amp;quot; =&amp;gt; &amp;quot;java.net.BindException: Address already in use /127.0.0.1:9990&amp;quot;}, &amp;quot;WFLYCTL0288: One or more services were unable to start due to one or more indirect dependencies not being available.&amp;quot; =&amp;gt; { &amp;quot;Services that were unable to start:&amp;quot; =&amp;gt; [&amp;quot;org.</description></item><item><title>MFA-OTP</title><link>https://l10178.github.io/idaas-book/keycloak/security-features/mfa/</link><pubDate>Mon, 14 Dec 2020 23:54:37 +0800</pubDate><guid>https://l10178.github.io/idaas-book/keycloak/security-features/mfa/</guid><description>MFA 即 Multi-Factor Authentication，多重身份认证，多因子认证，多因素认证。当然也包含等保要求中常说的双因子认证 2FA。
常见的实现如 U 盾、短信、邮件、指纹识别、面部识别等，在账户+密码基础上，进行二次或多次认证，增强数据安全。
Keycloak 提供了基于 OTP（One-Time Password，一次性密码，动态口令）的开箱即用的解决方案。
使用步骤 直接上图看效果。
各个 Realm 默认的浏览器认证流中，OTP 是CONDITIONAL，是一个条件可选项。 为用户配置启用 OTP 认证。 用户登录，未注册设备，要求注册设备。 手机端下载支持的 OTP 软件，如 FreeOTP，Google Authenticator。扫描注册，注册成功后就能看到已经生成一次性口令。 登录时就会要求输入一次性验证码。 注册成功后，可以在管理控制台看到用户注册的设备，用户也可以在自己的账户页面看到注册的设备。如果手机丢了想重新注册，把已有的记录删掉就可以，删掉后下次登录会要求重新注册。
管理控制台: 自己的账户页面：
扩展认证方式 如果想自己实现认证方式，官方也提供了详细的 SPI 开发指导，我们根据指导用一天时间实现了一个短信验证码。待开源。
名字解释 OTP One-Time Password，一般翻译为一次性密码、动态口令、动态验证码。
HOTP HMAC-based One-Time Password，使用计数方式基于 HMAC 算法加密。算法协议为 RFC 2104.
TOTP Time-based One-Time Password，基于时间戳算法，是时间同步，基于客户端的动态口令和服务器的时间比对，一般每 N 秒产生一个新口令，要求客户端和服务器能够保持正确的时钟，客户端和服务端基于时间计算的动态口令才能一致。算法协议为 RFC 6238.
开源实现
FreeOTP。 Google Authenticator。</description></item><item><title>安装AD域服务并启用LDAPS</title><link>https://l10178.github.io/idaas-book/references/windows-ad/</link><pubDate>Mon, 14 Dec 2020 23:54:37 +0800</pubDate><guid>https://l10178.github.io/idaas-book/references/windows-ad/</guid><description>说明：此步骤仅仅是为了如何快速搭建起一个测试版 Windows AD 服务，不可用于生产。
前置条件 安装 Windows AD 域控服务器，需要提前准备：
Windows Server 2008 及更新版本操作系统，如 4 核 8G 内存，60G 硬盘的主机一台。 提前规划好域名，比如本示例为 iam.nxest.local. Windows Server 不同版本略有差异，但是基本要做的就是下面几项：
启用功能：角色和功能里添加 Windows AD 域服务。 配置：配置 AD 域名、管理员密码等基本信息。 Windows Server 2012 步骤如下 点击开始菜单，找到“服务器管理器”，打开，显示如下界面。
点击右上角 管理&amp;gt;“添加角色和功能”按钮，弹出如下界面。
选择“基于角色或基于功能的安装”，然后点“下一步”。
服务器选择这里选择默认的，假如你需要针对其它主机安装 AD 角色，这里可以选择你需要的主机，点击“下一步”。
这里勾选“Active Directory 域服务”。
当勾选这个选项时，会弹出对话框，点“添加功能”，在功能这个选项卡直接点下一步，一直下一步直到最后一步点击安装。
安装成功后我们点击“关闭”，但这还没有完全安装成功，还需要继续配置。点击服务器右上角的“功能按钮”, 弹出继续配置 AD 的对话框。</description></item><item><title>密码策略</title><link>https://l10178.github.io/idaas-book/keycloak/security-features/password-policies/</link><pubDate>Mon, 14 Dec 2020 23:54:37 +0800</pubDate><guid>https://l10178.github.io/idaas-book/keycloak/security-features/password-policies/</guid><description>密码策略，常见的如密码最小长度、必须包含特殊字符、密码不能与历史密码相同等。控制用户在修改密码时，新密码必须满足一定的条件，从而增强密码安全。
Keycloak 内置了丰富的密码策略，满足常用的需求，不过默认都是不启用的，需要管理员主动设置。
启用方式，单击 Authentication 菜单，选择 Password Policy 选项卡。 在右侧下拉列表框中选择要添加的策略。根据策略提示设置不同的参数，保存。
密码策略只对新创建用户，或者用户修改密码生效，对已有用户不生效。如果想更快生效，就强制用户必须修改密码，在用户的 Required User Actions 里增加 Update Password 。
密码策略类型 HashAlgorithm
哈希算法，密码加密算法，以此算法存储，可根据官方指导自己实现算法。
Hashing Iterations
哈希次数，指定密码在存储或验证之前被哈希的次数。 多次哈希防止数据库泄露后，密码被暴力破解。哈希次数越多安全性越高，性能越差。
Minimum Length
密码最小长度。加大密码长度才是最有效的安全措施，什么大小写数字都是骗人的。
Digits
密码里必须包含 N 个数字。
Lowercase Characters
密码里必须包含 N 个小写字母。
Uppercase Characters
密码里必须包含 N 个大写字母。
Special Characters
密码里必须包含 N 个特殊字符，特殊字符如 ?!#%$ 。
Not Username
不能是当前用户名。
Not Email</description></item><item><title>Https Required</title><link>https://l10178.github.io/idaas-book/keycloak/troubleshooting/https-required/</link><pubDate>Thu, 10 Dec 2020 23:59:00 +0800</pubDate><guid>https://l10178.github.io/idaas-book/keycloak/troubleshooting/https-required/</guid><description>问题描述 以 Http 方式登录，页面错误提示如下。
We're sorry... HTTPS required.
问题原因 keycloak 各个 Realm 默认的登录设置里，Require SSL 为 external requests，对于外部请求，必须是 Https。 非外部请求，也就是私有地址，可以是 http，如：localhost, 127.0.0.1, 10.x.x.x, 192.168.x.x, 172.16.x.x。 详细参考官方文档说明。
解决方案 配置 https 并使用 https 登录，毫无疑问，这是正确的解决方案。
如果只是测试环境，可以修改 Realm 的设置，Require SSL 改为 none。
修改数据方式
update REALM set ssl_required=&amp;#39;NONE&amp;#39; where id = &amp;#39;master&amp;#39;; K8S 命令行调用 keycloak 官方 admin 工具 kcadm 修改
# login with a admin user kubectl exec -it keycloak-pod -- /opt/jboss/keycloak/bin/kcadm.</description></item><item><title>Liquibase MGR</title><link>https://l10178.github.io/idaas-book/keycloak/troubleshooting/liquibase-mysql-group-replication/</link><pubDate>Tue, 08 Dec 2020 23:50:37 +0800</pubDate><guid>https://l10178.github.io/idaas-book/keycloak/troubleshooting/liquibase-mysql-group-replication/</guid><description>问题描述 Keycloak 对接的是一个 MGR(mysql group replication)的集群，安装时出错，数据初始化失败。
查看 keycloak 启动日志，错误信息大致如下。
INFO [org.keycloak.connections.jpa.updater.liquibase.LiquibaseJpaUpdaterProvider] (ServerService Thread Pool -- 66) Initializing database schema. Using changelog META-INF/jpa-changelog-master.xml ERROR [org.keycloak.connections.jpa.updater.liquibase.conn.DefaultLiquibaseConnectionProvider] (ServerService Thread Pool -- 66) Change Set META-INF/jpa-changelog-1.0.0.Final.xml:: 1.0.0.Final-KEYCLOAK-5461::sthorger@redhat.com failed. Error: Table 'APPLICATION_DEFAULT_ROLES' already exists [Failed SQL: CREATE TABLE keycloak.APPLICATION_DEFAULT_ROLES (APPLICATION_ID VARCHAR(36) NOT NULL, ROLE_ID VARCHAR(36) NOT NULL)] FATAL [org.keycloak.services] (ServerService Thread Pool -- 66) java.lang.RuntimeException: Failed to update database INFO [org.jboss.as.server] (Thread-2) WFLYSRV0220: Server shutdown has been requested via an OS signal 查看 MySQL 日志，看到如下错误。</description></item><item><title>暴力检测</title><link>https://l10178.github.io/idaas-book/keycloak/security-features/brute-force-detection/</link><pubDate>Fri, 04 Dec 2020 23:54:37 +0800</pubDate><guid>https://l10178.github.io/idaas-book/keycloak/security-features/brute-force-detection/</guid><description>Brute Force Detection 暴力检测，防止密码暴力破解，登录失败 N 次锁定。
启用暴力检测 控制台选择 Realm，设置：Realm Settings -&amp;gt; Security Defenses -&amp;gt; Brute Force Detection。
Permanent Lockout
ON 表示永久锁定。
OFF 表示临时锁定。
Max Login Failures
登录失败达到多少次时，锁定账号。
Quick Login Check Milli Seconds
快速登录检测，两次登录请求之间的时间间隔（单位毫秒）小于该值时，则认定为快速登录。
Minimum Quick Login Wait
一旦被认定为快速登录，该账号将被临时锁定为该配置项配置的时长。
解除锁定 临时锁定用户，达到锁定时长后，会自动解锁。
管理员在用户列表或用户详情里可以手动解锁。
注意事项 失败次数统计仅与登录账号相关，与会话无关，关闭重启浏览器，次数不会重置。 用户锁定后，给出的错误提示还是默认的用户名密码错误，就是不想让攻击者知道用户暂时被禁用了。</description></item><item><title>用户增删改查</title><link>https://l10178.github.io/idaas-book/keycloak/admin-api/user-end2end/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://l10178.github.io/idaas-book/keycloak/admin-api/user-end2end/</guid><description>Keycloak Admin REST API，curl 模拟用户增加修改删除的完整例子。
#!/bin/bash HOST_IP=127.0.0.1 HOST_NAME=keycloak.example DEFAULT_REALM=master ADMIN_API_URL=http://${HOST_IP}/auth/admin/realms/${DEFAULT_REALM} USER_API_URL=${ADMIN_API_URL}/users # admin user ADMIN_NAME=xxx ADMIN_PWD=xxx parse_json() { echo &amp;#34;${1//\&amp;#34;/}&amp;#34; | sed &amp;#34;s/.*$2:\([^,}]*\).*/\1/&amp;#34; } echo &amp;#34;====Begin test user CRUD====&amp;#34; token_url=http://${HOST_IP}/auth/realms/${DEFAULT_REALM}/protocol/openid-connect/token # Get token, a json token_json=$(curl -X POST \ -H &amp;#34;host:${HOST_NAME}&amp;#34; \ -H &amp;#34;Content-Type: application/x-www-form-urlencoded&amp;#34; \ ${token_url} \ --data &amp;#39;grant_type=password&amp;#39; \ --data &amp;#39;client_id=admin-cli&amp;#39; \ --data &amp;#34;username=${ADMIN_NAME}&amp;#34; \ --data &amp;#34;password=${ADMIN_PWD}&amp;#34;) # get the `access_token` from the json token=$(parse_json &amp;#34;$token_json&amp;#34; &amp;#34;access_token&amp;#34;) # List users curl -X GET -H &amp;#34;Authorization: Bearer ${token}&amp;#34; \ -H &amp;#34;host:${HOST_NAME}&amp;#34; \ ${USER_API_URL} -v # Add new user username=usertest$(date &amp;#34;+%Y%m%d%H%M%S%s&amp;#34;) user={\&amp;#34;enabled\&amp;#34;:true,\&amp;#34;attributes\&amp;#34;:{},\&amp;#34;username\&amp;#34;:\&amp;#34;${username}\&amp;#34;,\&amp;#34;emailVerified\&amp;#34;:\&amp;#34;\&amp;#34;} echo &amp;#34;Begin create new user ${username}.</description></item></channel></rss>